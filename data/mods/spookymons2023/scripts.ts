export const Scripts: {[k: string]: ModdedBattleScriptsData} = {
	teambuilderConfig: {
		excludeStandardTiers: true,
		customTiers: ['Evo!', 'Evo NFE!', 'Evo (NFE)'],//Adding a new tier for NFEs that I don't want buried in the lower section [like Michu :(]
		customDoublesTiers: ['Evo!', 'Evo NFE!', 'Evo (NFE)'],
	},
	init() {
		for (const id in this.dataCache.Pokedex) {
			const newMon = this.dataCache.Pokedex[id];
			if (!newMon || !newMon.copyData) continue; // weeding out PokÃ©mon that aren't new
			const copyData = this.dataCache.Pokedex[this.toID(newMon.copyData)];

			if (!newMon.types && copyData.types) newMon.types = copyData.types;
			if (!newMon.baseStats && copyData.baseStats) newMon.baseStats = copyData.baseStats;
			if (!newMon.abilities && copyData.abilities) newMon.abilities = copyData.abilities;
			if (!newMon.num && copyData.num) newMon.num = copyData.num * -1; // inverting the original's dex number
			if (!newMon.genderRatio && copyData.genderRatio) newMon.genderRatio = copyData.genderRatio;
			if (!newMon.heightm && copyData.heightm) newMon.heightm = copyData.heightm;
			if (!newMon.weightkg && copyData.weightkg) newMon.weightkg = copyData.weightkg;
			if (!newMon.color && copyData.color) newMon.color = copyData.color;
			if (!newMon.eggGroups && copyData.eggGroups) newMon.eggGroups = copyData.eggGroups;

			let copyMoves = newMon.copyData;
			if (newMon.copyMoves) copyMoves = newMon.copyMoves;
			if (copyMoves) {
				if (!this.dataCache.Learnsets[id]) this.dataCache.Learnsets[id] = {learnset: {}}; // create a blank learnset entry so we don't need a learnsets file (thank you ink)
				const learnset = this.dataCache.Learnsets[this.toID(copyMoves)].learnset;
				for (const moveid in learnset) {
					this.modData('Learnsets', id).learnset[moveid] = learnset[moveid].filter(
						(method) => !method.includes('S')
					);
				}
				if (newMon.movepoolAdditions) {
					for (const move of newMon.movepoolAdditions) {
						this.modData('Learnsets', this.toID(id)).learnset[this.toID(move)] = ["8M"];
					}
				}
				if (newMon.movepoolDeletions) {
					for (const move of newMon.movepoolDeletions) {
						delete this.modData('Learnsets', this.toID(id)).learnset[this.toID(move)];
					}
				}
				// hard-coding a bit for Eclipseroid specifically (may rework if we get more fusions later but kinda doubt)
				if (newMon.name === 'Eclipseroid') {
					for (const moveid in this.dataCache.Learnsets[this.toID("Lunatone")].learnset) {
						this.modData('Learnsets', id).learnset[moveid] = this.dataCache.Learnsets[this.toID("Lunatone")].learnset[moveid].filter(
							(method) => !method.includes('S')
						);
					}
				}
			}
		}
	},
	pokemon: {
		getHealth = () => { // modded for Baneful Transformation
			if (!this.hp) return {side: this.side.id, secret: '0 fnt', shared: '0 fnt'};
			let secret = `${this.hp}/${this.maxhp}`;
			let shared;
			const ratio = this.hp / this.maxhp;
			if (this.battle.reportExactHP) {
				shared = secret;
			} else if (this.battle.reportPercentages || this.battle.gen >= 8) {
				// HP Percentage Mod mechanics
				let percentage = Math.ceil(ratio * 100);
				if ((percentage === 100) && (ratio < 1.0)) {
					percentage = 99;
				}
				shared = `${percentage}/100`;
			} else {
				// In-game accurate pixel health mechanics
				const pixels = Math.floor(ratio * 48) || 1;
				shared = `${pixels}/48`;
				if ((pixels === 9) && (ratio > 0.2)) {
					shared += 'y'; // force yellow HP bar
				} else if ((pixels === 24) && (ratio > 0.5)) {
					shared += 'g'; // force green HP bar
				}
			}
			if ('banefultransformation' in this.volatiles) shared = `100/100g`; // only modded line
			if (this.status) {
				secret += ` ${this.status}`;
				shared += ` ${this.status}`;
			}
			return {side: this.side.id, secret, shared};
		};
	},
};
